# Part of this file was taken from Viper - https://github.com/botherder/viper
# The rest is from the Stratosphere Testing Framework
# See the file 'LICENSE' for copying permission.

# This module implements markov chains of first order over the letters in the chain of states of the behavioral models.
import persistent
import pykov
import BTrees.OOBTree

from stf.common.out import *
from stf.common.abstracts import Module
from stf.core.models import  __groupofgroupofmodels__ 
#from stf.core.dataset import __datasets__
#from stf.core.notes import __notes__
#from stf.core.connections import  __group_of_group_of_connections__
#from stf.core.models_constructors import __modelsconstructors__ 
from stf.core.labels import __group_of_labels__
from stf.core.database import __database__



"""
     def our_walk(self,P,v_state):  
        #Get a markov chain and a group of states, and compute the probability that this group was generated by this markov chain.
        #Our computation is different of the normal one in:
        #- If a transition of states is not in the MC, then we store the prob until this point, and we start again from the next state. This way we search for the sub-chain of states with the max prob on this MC.
        try:
            global debug
            i = 0
            res = 1
            best_prob_so_far = 1           
            while i < len(v_state):        
                try:
                    vector = [v_state[i], v_state[i+1]]
                    wv = P.walk_probability(vector)
                    prob = math.exp(wv)            

                    if debug > 6:                  
                        print '\t\tVector: {}. Prob:{:.10f}'.format(vector, prob)
                    # Here is our trick. If two letters are not in the matrix...
                    if prob != float('-inf'):      
                        if prob == 0.0:                
                            if debug > 6:                  
                                print '\t\t\tThis transition is not in the matrix.'

                            # Only change the best_prob_so_far on the next pair that we can't find.
                            if res < best_prob_so_far:     
                                best_prob_so_far = res         
                            else:                          
                                # Reset the prob               
                                res = 1                        
                        else:
                            # Normal MC computation. The probs of all the matching pair of letters so far, are multiplied.
                            res = res * prob               
                    if debug > 6:                  
                        print '\t\t\tRes:{}. Best prob so far: {:.10f}'.format(res, best_prob_so_far)
                except IndexError:             
                    # We are out of letters        
                    break
                i += 1

            # Just in case the best one is the last one
            if res < best_prob_so_far:     
                best_prob_so_far = res         
            
            if debug > 6:
                print '\t\t\tFinal prob: {}'.format(best_prob_so_far)
            return best_prob_so_far        
    

        except Exception as inst:      
            print 'Problem in our_walk() in class stateModels'
            print type(inst)     # the exception instance
            print inst.args      # arguments stored in .args
            print inst           # __str__ allows args to printed directly
            exit(-1)
"""





#################
#################
#################
class Markov_Model(persistent.Persistent):
    """ This class is the actual markov model of first order to each label"""
    def __init__(self, id):
        self.mm_id = id
        self.state = ""
        self.label_id = -1
        self.connections = BTrees.OOBTree.BTree()

    def get_id(self):
        return self.mm_id

    def set_id(self, id):
        self.mm_id = id

    def get_state(self):
        return self.state

    def set_state(self, state):
        self.state = state

    def get_label_id(self):
        return self.label_id

    def set_label_id(self, label_id):
        self.label_id = label_id

    def get_connections(self):
        return self.connections
    
    def set_connections(self, connections):
        self.connections = connections

    def count_connections(self):
        """ Return the amount of connections in the markov model """
        count = 0
        for id in self.connections:
            for conn in self.connections[id]:
                count += 1
        return count

    def get_init_vector(self):
        return self.init_vector

    def get_matrix(self):
        return self.matrix

    def create(self):
        """ Create the Markov chain itself """
        # Separete the letters considering the letter and the simbol as a unique state:
        # So from "88,a,b," we get: '8' '8,' 'a,' 'b,'
        try:
            separated_letters=[]
            separated_letters.append(self.state[0])
            i = 1
            while i <= len(self.state):
                separated_letters.append(self.state[i:i+2])
                i+=2
        except AttributeError:
            print_error('There is no state yet')
            return False
        # Generate the MC
        self.init_vector, self.matrix = pykov.maximum_likelihood_probabilities(separated_letters, lag_time=1, separator='#')

    def print_matrix(self):
        for first in self.matrix:
            print first, self.matrix[first]

    def simulate(self, amount):
        """ Generate a simulated chain using this markov chain """
        chain = ''
        chain += self.state[0]
        chain += self.state[1]
        chain += self.state[2]
        chain += ''.join(self.matrix.walk(amount))
        print chain
        return True






######################
######################
######################
class Group_of_Markov_Models_1(Module, persistent.Persistent):
    cmd = 'markov_models_1'
    description = 'This module implements markov chains of first order over the letters in the chains of states in a LABEL.'
    authors = ['Sebastian Garcia']
    # Markov Models main dictionary
    markov_models = BTrees.OOBTree.BTree()

    # Mandatory Method!
    def __init__(self):
        # Call to our super init
        super(Group_of_Markov_Models_1, self).__init__()
        self.parser.add_argument('-l', '--list', action='store_true', help='List the markov models already applied')
        self.parser.add_argument('-g', '--generate', metavar='generate', help='Generate the markov chain for this label. Give label name.')
        self.parser.add_argument('-m', '--printmatrix', metavar='printmatrix', help='Print the markov chains matrix of the given markov model id.')
        self.parser.add_argument('-s', '--simulate', metavar='simulate', help='Use this markov chain to generate a new simulated chain of states. Give the markov chain id. The length is now fixed in 100 states.')

    # Mandatory Method!
    def get_name(self):
        """ Return the name of the module"""
        return self.cmd

    # Mandatory Method!
    def get_main_dict(self):
        """ Return the main dict where we store the info. Is going to the database"""
        return self.markov_models

    # Mandatory Method!
    def set_main_dict(self, dict):
        """ Set the main dict where we store the info. From the database"""
        self.markov_models = dict

    def get_markov_model(self, id):
        return self.markov_models[id]

    def get_markov_models(self):
        return self.markov_models.values()

    def print_matrix(self, markov_model_id):
        try:
            self.markov_models[int(markov_model_id)].print_matrix()
        except KeyError:
            print_error('That markov model id does not exists.')

    def list_markov_models(self):
        print_info('Markov Models')
        rows = []
        for markov_model in self.get_markov_models():
            label_name = __group_of_labels__.get_label_name_by_id(markov_model.get_label_id())
            rows.append([ markov_model.get_id(), len(markov_model.get_state()), markov_model.count_connections(), label_name ])
        print(table(header=['Id', 'State Len', '# Connections', 'Label'], rows=rows))

    def create_new_model(self, label_name):
        """ Given a label name create a new markov chain object"""
        # Get the label object
        label_to_model = __group_of_labels__.get_label(label_name)
        if label_to_model:
            # Create a new markov chain object
            ## Get the new id
            try:
                mm_id = self.markov_models[list(self.markov_models.keys())[-1]].get_id() + 1
            except (KeyError, IndexError):
                mm_id = 1
            markov_model = Markov_Model(mm_id)
            # Store the label id
            markov_model.set_label_id(label_to_model.get_id())
            state = ""
            # Get all the connections in the label
            connections = label_to_model.get_connections_complete()
            # Get all the group of models and connections names
            for group_of_model_id in connections:
                # Get all the connections
                for conn in connections[group_of_model_id]:
                    # Get the model group
                    group = __groupofgroupofmodels__.get_group(group_of_model_id)
                    # Get the model
                    model = group.get_model(conn)
                    # Get each state
                    state += model.get_state() + '#'
            # Store the state
            markov_model.set_state(state)
            # Store the connections
            markov_model.set_connections(connections)
            # Create the MM itself
            markov_model.create()
            # Store
            self.markov_models[mm_id] = markov_model
        else:
            print_error('No label with that name')

    def simulate(self, markov_model_id):
        """ Generate a new simulated chain of states for this markov chain """
        try:
            markov_model = self.get_markov_model(int(markov_model_id))
            markov_model.simulate(100)
        except KeyError:
            print_error('No such markov model id')


    # The run method runs every time that this command is used
    def run(self):
        # Register the structure in the database, so it is stored and use in the future. 
        if not __database__.has_structure(Group_of_Markov_Models_1().get_name()):
            print_info('The structure is not registered.')
            __database__.set_new_structure(Group_of_Markov_Models_1())
        else:
            main_dict = __database__.get_new_structure(Group_of_Markov_Models_1())
            self.set_main_dict(main_dict)

        # List general help
        def help():
            self.log('info', "Markov Models of first order")

        # Run
        super(Group_of_Markov_Models_1, self).run()
        if self.args is None:
            return
        
        # Process the command line
        if self.args.list:
            self.list_markov_models()
        elif self.args.generate:
            self.create_new_model(self.args.generate)
        elif self.args.printmatrix:
            self.print_matrix(self.args.printmatrix)
        elif self.args.simulate:
            self.simulate(self.args.simulate)
        else:
            print_error('At least one of the parameter is required in this module')
            self.usage()

